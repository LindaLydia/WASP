import sys, os
import matplotlib.pyplot as plt
import numpy as np
import torch
import re

ACC = [
    [78.28, 85.00, 82.25, 67.74, 73.30],
    [65.81, 64.59, 69.54, 61.41, 78.82]
]

FID = [
    [22.26, 21.95, 21.91, 20.96, 20.37],
    [21.80, 18.80, 18.52, 18.34, 18.15], 
]

PLM_NAME = ['GPT-2', 'OPT']


def plot_fid_acc_incorrelation(acc_results, fid_results, plm_names):
    fig, axs = plt.subplots(nrows=1, ncols=len(plm_name), figsize=(18 if args.consider_real else 16, 3*(args.steps+1+0.2)), sharex=True, sharey=True)
    for i_step in range(1,args.steps+2):
        for i in range((args.len_LLM+1 if args.consider_real else args.len_LLM)):
            # for ir, label in enumerate(label_unique_values):
            if i < args.len_LLM:
                # temp_embeddings_2d = np.array(embeddings_2d[args.accumulate_sampels[i]:args.accumulate_sampels[i]+int(args.num_use_samples_inner[i]*(i_step/(args.steps+1))), :])
                # temp_labels = labels[args.accumulate_sampels[i]:args.accumulate_sampels[i]+int(args.num_use_samples_inner[i]*(i_step/(args.steps+1)))]
                _previous_step_obtain = args.step_sample_count[i_step-2][i] if i_step > 1 else 0
                temp_embeddings_2d = np.array(embeddings_2d[args.accumulate_sampels[-1][i]+_previous_step_obtain:args.accumulate_sampels[-1][i]+args.step_sample_count[i_step-1][i], :])
                temp_labels = labels[args.accumulate_sampels[-1][i]+_previous_step_obtain:args.accumulate_sampels[-1][i]+args.step_sample_count[i_step-1][i]]
            else:
                temp_embeddings_2d = np.array(embeddings_2d[args.accumulate_sampels[-1][i]:, :])
                temp_labels = labels[args.accumulate_sampels[-1][i]:]
            # temp_embeddings_2d = embeddings_2d[args.accumulate_sampels[i]:args.accumulate_sampels[i+1], :]
            # temp_labels = labels[args.accumulate_sampels[i]:args.accumulate_sampels[i+1]]
            # class_mask = (temp_labels==0).astype(np.int64)
            # class_mask = np.nonzero(class_mask)[0]
            # for ic in class_mask[110:120]:
            #     print(int(ic))
            color_list = [colors[1-int(ic)] for ic in temp_labels]
            marker_list = [markers[1-int(ic)] for ic in temp_labels]
            # print(type(class_mask), class_mask.shape, class_mask.dtype)
            # print(temp_embeddings_2d[class_mask, 0])
            axs[i_step-1][i].scatter(temp_embeddings_2d[:, 0], temp_embeddings_2d[:, 1], color=color_list, marker='o',
                        # label=(f'{LLM_names[i]} if i<args.len_LLM else 'Golden Data'), 
                        alpha=0.3) #+f'\nclass {ir}'
            axs[i_step-1][i].set_title(f'{LLM_names[i]}', fontsize=14)
            # axs[i].legend(loc='upper center')
        # fig.suptitle('t-SNE Visualization of Embeddings for syndataset generated by different LLMs')
        # plt.xlabel('Dimension 1')
        # plt.ylabel('Dimension 2')
        # plt.legend()
        plt.tight_layout()
        if not os.path.exists(f'./figure/distribution/2D/{args.folder_name}/'):
            os.makedirs(f'./figure/distribution/2D/{args.folder_name}/')
        print(f'./figure/distribution/2D/{args.folder_name}/bystep_{save_type}_{f"with{args.gold_data_num}" if args.consider_real else "without"}test_withLabel.png')
        plt.savefig(f'./figure/distribution/2D/{args.folder_name}/bystep_{save_type}_{"with" if args.consider_real else "without"}test_withLabel.png',dpi=200)


if __name__ == "__main__":
    plot_fid_acc_incorrelation(ACC,FID,PLM_NAME)